# Razorpay Payment Gateway Microservice Architecture (Node.js) with Secure Webhooks

This detailed guide will walk you through designing and implementing a **secure, optimized, and scalable payment gateway microservice** using Razorpay in Node.js, with an emphasis on security and best practices. 

## 1. **Architecture Overview**

- Use **Node.js** with a framework like Express.js or Fastify.
- Deploy payment logic as a **microservice** (separate module/container).
- Expose secure REST APIs for your frontend (e.g., `/create-order`, `/fetch-status`).
- Implement a **dedicated secure webhook endpoint** for Razorpay event notifications.
- Use a queue (e.g., RabbitMQ, SQS, BullMQ) for heavy/async processing.

## 2. **Components Checklist**

- Razorpay backend microservice (Node.js)
- Secure API authentication (JWT, API keys, OAuth)
- HTTPS enabled (SSL/TLS)
- Secure, authenticated **webhook endpoint**
- Database (for persistent payment/event logs)
- Message queue (for async/event processing)
- Logging and monitoring (e.g., Winston, PM2, ELK, Sentry)
- Environment variable management (never hardcode secrets!)
- Rate limiting and denial of service protection

## 3. **Razorpay Integration Steps**

### a. **Environment Setup**

Set these in your environment variables, not in code:

``` .env
RAZORPAY_KEY_ID=your_key_id
RAZORPAY_KEY_SECRET=your_key_secret
RAZORPAY_WEBHOOK_SECRET=webhook_secret_you_set_in_dashboard
```

### b. **REST API Endpoints**

Example endpoints to expose in your microservice:

- `POST /api/payments/order` – Create a payment order
- `GET /api/payments/:id/status` – Check payment status
- `POST /api/payments/razorpay/webhook` – Handle Razorpay webhooks

Only expose essential endpoints; use authentication and authorization for every route, except the webhook receiver.

## 4. **Webhook Endpoint (Backend Only, No UI)**

#### Example: `/api/payments/razorpay/webhook`

- Accept only **POST** requests.
- Validate the **X-Razorpay-Signature** header with your Razorpay webhook secret.
- Handle only allowed events.
- Log every received event (for audit/trouble-shooting).
- Respond with `200 OK` promptly after processing.
- Never expose sensitive logic here; only receive, validate, and queue/trigger business logic.

## 5. **Security Best Practices**

### a. **Secret & Key Management**
- **Never hardcode keys/secrets**—use .env files and secrets managers (e.g., AWS Secrets Manager, HashiCorp Vault).
- Regular rotation of all secrets (key ID, webhook secret).

### b. **HTTPS/TLS**
- Always serve APIs and webhooks via HTTPS (port 443).
- Use valid CA-signed certificates.

### c. **Webhook Signature Validation**
- Validate the hash provided in `X-Razorpay-Signature` with the payload and your webhook secret.
- Reject the request if the signature is missing or does not match.

### d. **Input Validation**
- Sanitize and validate **all incoming data**—not just webhooks but user/API requests.
- Use libraries like Joi, express-validator, or Zod.

### e. **Authentication & Authorization**
- Use strong API authentication for internal APIs (JWT, API keys).
- Never expose payment or event data to non-authorized clients or endpoints.

### f. **Rate Limiting & DoS Protection**
- Apply rate limiting (libraries like express-rate-limit or external tools like Cloudflare/WAF).
- Monitor and alert on suspicious/burst traffic.

### g. **Audit Logging**
- Log all payment and webhook events. Store securely with restricted access.
- Never log sensitive data (card numbers, CVVs, etc.).

### h. **Alerting & Monitoring**
- Send alerts on suspicious or failed payment events.
- Monitor logs and metrics proactively.

### i. **CORS and Header Protection**
- Lock down CORS to required origins only.
- Set appropriate HTTP headers (e.g., Helmet middleware).

### j. **Restrict IPs (Optional)**
- Optionally, allowlist Razorpay’s IPs for webhook endpoint (may require regular updates).

## 6. **Scalability & Optimization**

- Stateless microservice scaling (Docker, Kubernetes, etc.).
- Use background jobs/message queues for heavy or delayed work.
- Quick webhook response; async processing for downstream effects (emails, updates).
- Use caching for frequent reads (redis, etc.).
- Monitor performance metrics (latency, QPS, error rate).

## 7. **Example: Node.js (Express) Secure Webhook Handler**

```javascript
// Dependencies
const crypto = require('crypto');
const express = require('express');
const router = express.Router();

router.post('/razorpay/webhook', express.json(), (req, res) => {
  const secret = process.env.RAZORPAY_WEBHOOK_SECRET;
  const signature = req.headers['x-razorpay-signature'];
  const generatedSignature = crypto
    .createHmac('sha256', secret)
    .update(JSON.stringify(req.body))
    .digest('hex');

  if (signature !== generatedSignature) {
    return res.status(401).send('Invalid signature');
  }

  // Validate event type
  if (!['payment.captured', 'order.paid', 'payment.failed'].includes(req.body.event)) {
    return res.status(200).send('Event ignored');
  }

  // Enqueue for async processing
  yourQueue.push(req.body);

  // Log event
  logger.info('Webhook event received', req.body);

  res.status(200).send('Webhook received');
});

module.exports = router;
```
- This code validates the Razorpay signature, checks event type, and promptly responds.

## 8. **Setting Up Webhook on Razorpay Dashboard**

- Go to Razorpay Dashboard > Settings > Webhooks.
- Add:
  - **URL:** `https://api-curveai.com/razorpay/webhook`
  - **Secret:** [Your chosen webhook secret, store in backend only]
  - **Events:** Select only the events you need  payment Events
payment.authorized
payment.failed
payment.captured
payment.dispute.created
payment.dispute.won
payment.dispute.lost
payment.dispute.closed
payment.dispute.under_review
payment.dispute.action_required
payment.downtime.started
payment.downtime.updated
payment.downtime.resolved
order Events
order.paid
order.notification.delivered
order.notification.failed
invoice Events
invoice.paid
invoice.partially_paid
invoice.expired
fund_account Events
fund_account.validation.completed
fund_account.validation.failed
refund Events
refund.speed_changed
refund.processed
refund.failed
refund.created
account Events
account.instantly_activated
account.activated_kyc_pending
payment_link Events
payment_link.paid
payment_link.partially_paid
payment_link.expired
payment_link.cancelled


## 9. **Testing & Simulation**

- Use Razorpay’s test cards for end-to-end test payments in "Test Mode".
- Trigger test webhooks from the Razorpay Dashboard to your dev URL (use ngrok to tunnel localhost if local testing).
- You can also POST simulated webhook payloads from Postman (with valid signature) to test.

## 10. **Frontend (curveai.com) Integration**

- Frontend always interacts with **backend APIs—never with Razorpay directly after payment**.
- To display payment status: your frontend fetches data from backend `/payments/:id/status`.
- No sensitive logic or credentials ever sent to frontend.

## 11. **Compliance & Documentation**

- Periodically review Razorpay documentation for updates on events, security, allowed IPs.
- Prepare for audits: Document design, flow, security controls, incident response.

# **Template Directory Structure**

```
/api
   |-- payments.js (API routes)
   |-- webhook.js (Razorpay webhook handler)
/
.env (Never commit this!)
PAYMENT_GATEWAY.md (this file)
```

# **References**

- Razorpay official documentation (API, webhooks, Node.js SDK)
- Node.js and Express.js security guides

**For production, perform security reviews, penetration tests, and regular audits to ensure your payment microservice is not just robust and scalable, but also absolutely secure.**